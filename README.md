# ArgParseLang

The ArgParse Language was created to help you to create boiler plate code to parse command line arguments.

Today, ArgParse supports two languages:

- Python 2/3
- Bash

## Installing / Dev environment
- `mkvirtualenv ArgParseLang -p python3` to make a isolated python environment
- `pip install -r requirements.txt` to install python dependencies
- `./get_antlr.sh` to download antlr jars
- `source ./antlr_alias.sh` to configure antlr aliases


## Language Specification
ArgParse is very simple, it have basically 4 types of command line arguments:

- Flags
- Named Attributes
- Arguments (not supported for bash yet)
- Positional Arguments

### Flags
Flags are command line arguments that dont need any extra information beyond itself. It is used basically to indicated some boolean variable. You can use flags in command line arguments by using a single dash followed by a name, as: `my_program -h -j`. In this case we have two flags. When we have many flags we can write `my_program -hj` too. Traditionally flags are indicated by one single letter, but you can create long named flags too, in this case you cannot group many flags together using a single dash, you will need to separate each flag, as: `my_program -help -cp` and **not** `my_program -helpcp`.

### Named Attributes
Differently from flags, named attributes need extra information. They are indicated by two dashes followed by a name, as: `my_program --name=John --surname=Travolta`.

### Arguments
Arguments is as we call here the undefined number of unamed arguments received by a command line program. Many programs receive many files to process, for example, so, is very common to see something like: `my_program FILE1 FILE2 FILE3`. The program doesn't know how many files can receive.

### Positional Arguments
Positional Arguments are very likely "Arguments" the difference is that the number of arguments is known, for example a program that receive a source to process and a file path to save the result, as: `my_program INPUT OUTPUT`.

### Syntax
ArgParse syntax is very simple, in the first lines you must describe your program. Include two blank lines. And them you will specify the command line arguments that you want. The general syntax of a argument is:

```
TYPE: ARGUMENTNAME DESCRIPTION
TYPE: ARGUMENTNAME2 DESCRIPTION2
```

Each argument must be separated from each other by one line. The possible types are: `FLAG` for flags, `ATTR` for named arguments, `POS` for positional arguments and `ARGS` for (undefined number of) arguments.


### Complete Example
One complete example is:

```
This program sums two numbers.
Made in MIT / NASA labs


POS:   A    the first term of sum
POS:   B    the second term of sum
FLAG:  bin  outputs the result in binary
FLAG:  hex  outputs the result in hexadecimal
```

Save this content in a file named `my_arguments.argparse`.
To create the python code to parse these arguments you must do:

```bash
python main.py my_arguments.argparse --lang=python > my_program.py
```

This command will create a file named `my_program.py` in your current folder. If you do:

```bash
python my_program.py --help
```

You will see:

```
usage: my_program.py [-h] [-bin] [-hex] A B

This program sums two numbers Made in MIT NASA labs

positional arguments:
  A           the first term of sum
  B           the second term of sum

optional arguments:
  -h, --help  show this help message and exit
  -bin        outputs the result in binary
  -hex        outputs the result in hexadecimal
```

## Use in production
To use in production is usefull to separate the ArgParse generated code from the code of your application. Below you will find the tips to achieve that in each output language.

### Python
Having a argparse file named `cl_arguments.argparse`, you can generate a separated python file named `cl_arguments.py` with `python main.py cl_arguments.argparse --lang=python > cl_arguments.py`. Do not edit this file, instead, create another file named `main.py` and do:

```python
from cl_arguments import args

if args.my_flag:
	launch_space_ship()

...
```

### Bash
Having a argparse file named `cl_arguments.argparse`, you can generate a separated bash file named `cl_arguments.sh` with `python main.py cl_arguments.argparse --lang=bash > cl_arguments.sh`. Do not edit this file, instead, create another file named `main.sh` and do:

```bash
# the dot here is an alias to "source", its an import
. cl_arguments.sh

# in the outputed bash file, is created a variable to each command line.
# The variables is upper case
echo $MY_FLAG
```

## Testing ArgParse
WIP

## Help Wanted
We need help to:

- create more output languages:
	- ~~Python~~
	- ~~Bash~~
	- C/C++
	- C#
	- Java
	- Lua
	- Ruby
	- Rust
	- Nim
	- Lua
	- Perl
	- JavaScript/NodeJS
	- Javascript variants (Coffescript, dart, typescript...)
	- Crystal
	- V
	- D
	- R
	- Ada
	- Haskell
	- Lisp
	- SmallTalk
	- AngelScript
	- Vala
	- put your language here...